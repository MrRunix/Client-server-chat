# Client-server Chat

##  Что же собственно нужно сделать???
> ЗАДАЧА:
Сделать чат. Большая его часть была выполнена в классных работах, осталось:
+  Добавить список пользователей 
+  Пользователи теперь общаются друг с другом, а не с сервером 
+  На подключение пользователя ему сервер отправляет сообщение со списком пользователей для общения на выбор 
+  Описать и оформить код (желательно оформить код по PEP8, но главное - комментарии и аккуратность). Структура проектного задания: 
+ +  Описание работы: в чём задание, что использовалось, как работает, на чём основано, какие технологии используются 
+ +  Теоретическая часть: подробная теоретическая сводка по предыдущему пункту 
+ +  Практическая часть: ваш код с описаниями блоков. что в нём происходит, как это работает, зачем это нужно 
+ +  Скриншоты работы в разных ситуациях 
+ +  Выводы  
+ +  Минимальная структура скриншотов:  запуск сервера, подключение пользователей, выбор пользователей для общения, отправка и приём сообщения соответствующими пользователями


## Ход работы)

> Выбор методов

+ Будем использовать `socket` для организации подключения и передачи сообщений между сервером и клиентами
+ Как ячейку хранения, будем использовать словари `dict`. В качестве ключа будем хранить адресс, а в качестве значения - никнейм.
+ Реализуем набор флагов, для удобства общения, как с одним, так и со всеми пользователями одновременно.
+ Будем использовать `threatings` для чтения сообщений на клиенте
+ Для отправки и обработки реализуем бесконечный цикл и напичкаем условиями
+ Используем кодировку `utf-8`

> Теоретическаяя сводка по методам
+ Как же работает `socket`?
+ + Есть серверный и клиентский сокеты. Серверный сокет прослушивает определенный порт, а клиентский подключается к серверу. После того, как было установлено соединение начинается обмен данными. Примеры:
+ + + Добавление сокета и установка прослушки на порт
+ + + sock = socket.socket() #ставим сокет
+ + + sock.bind (('127.0.0.1',4321))
+ Почему именно `dict` `s ?
+ + Во-первых, мы можем объединять в них никнейм и адресс.
+ + Во-вторых, удобный удобный формат хранения
+ + В-третьих, легче реализация проекта
+ + Примеры:
+ + + gg ('127.0.0.1', 52582), вот в таком формате будет хранитьса информация с сокета
+ + + Несколько полезных функций: 
+ + + + gict.get(addres) - получение значения по адресу
+ + + + dict.keys() - выводит в определённом формате все ключи
+ + + + dict.values() - выводит все значения в словаре
+ + + + dict.update({a:b}) - добавляет в словарь ключ a и его значение b
+ Как будут работать флаги?
+ + Каждый раз при вводе сообщения нужно добавлять флаг, от которого будет зависить дальнейший ход выполнения программы
+ + К примеру добавим флаг `-to` он будет означать, что мы хотим отправить личное сообщение
+ + Также нужна будет проверка на существование флага и наличие
+ Для чего нужен `threatings`?
+ + Этот модуль поможет на запускать отдельные функции в новом потоке.
+ + Примеры:
+ + + есть какая-то функция `get_addres`, но нам нужно запустить её паралельно другим важным процессам в коде
+ + + Тут-то и появляется `threatings`)) 
+ + + Обозначаем поток и ставим в него нашу функцию `thread = threading.Thread(target=read_msg)` и стартуем `thread.start()`
+ А что касательно бесконечного цикла?
+ + Всё просто, мы реализуем его, к примеру, на серваке и оставляем на нём обработку сообщений
+ + В бесконечном цикле мы проверяем его по флагам, разбираем и отправляем дальше
+ + Пример:
+ + + while 1:
+ + + msg = input()
+ + + if msg == "-1":
+ + +           break
+ Что за `utf-8`? 
+ + Так-с, это щифрование во время передачи сообщений
+ + Как пример, можем зашифровать строку "i am going home".encode("utf-8")
+ + Или "I will find u!!!".decode("utf-8") ой, разшифровали

> Варианты развития событий

+ Пользователь сначала должен будет выбрать себе ник, который впоследствии будет посылаться на сервер для проверки на уникальность
+ после этого будет сообщение, что подключение успешно и вывод сообщения с вызовом списка флагов
+ С помощью определённого флага пользователь получит список подключённых пользователей и выберет метод общения (всем или личное)
+ Указав нужный флаг пользователь будет отправлять сообщения, куда душе угодно
+ Реализуем функцию выхода с сервера, так, чтоб ник пользователя удалялся из базы
+ Добавим мемы, типо `down server`, которые смогут юзать админы
+ При отключении сервера будем выводит отпределённые сообщения всем пользователям

> Скриншоты вариаций выполнения

+ Начнём сначала: заход, команды, пользователи
![web](https://github.com/MrRunix/Client-server-chat/blob/main/screenshots/%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%801.png)
+ Затем обычные сообщения и проверка на существование пользователя
![web](https://github.com/MrRunix/Client-server-chat/blob/main/screenshots/%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%802.png)
+ Проверим ширик
![web](https://github.com/MrRunix/Client-server-chat/blob/main/screenshots/%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%803.png)
+ Проверка уникальности пользователей и фича
![web](https://github.com/MrRunix/Client-server-chat/blob/main/screenshots/%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80_down.png)
+ И небольшой прикольчик от меня
![web](https://github.com/MrRunix/Client-server-chat/blob/main/screenshots/%D0%BF%D1%80%D0%BC%D0%B5%D1%804.png)

> Выводы

Была поставлена задача, реализовать чат клиент-сревер. От выбора методов и до залития на гит, я наткнулся на множество особенностей структуры кода в python. Внедрял, переделывал, сносил, менял... Я считаю, что этот проект был отличным дополнием для изучения отдельных модулей. На данный момент времени, чат готов и ждёт своих клиентов, а я жду, когда мне принесут горячий кофе. Всем пис.